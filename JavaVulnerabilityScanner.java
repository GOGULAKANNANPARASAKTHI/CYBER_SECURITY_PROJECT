java
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

public class JavaVulnerabilityScanner {

public static void main(String[] args) {
String javaFilesDirectory = "java_files";
List<Result> allResults = analyzeDirectory(javaFilesDirectory);
 
// Output the results
for (Result result : allResults) {
System.out.println("File: " + result.getFile());
for (Vulnerability vulnerability : result.getVulnerabilities()) {
System.out.println(" Line " + vulnerability.getLine() + ": " + vulnerability.getName());
System.out.println(" ID: " + vulnerability.getId());
System.out.println(" Severity: " + vulnerability.getSeverity());
System.out.println(" Description: " + vulnerability.getDescription());
System.out.println(" Recommendation: " + vulnerability.getRecommendation());
}
System.out.println();
}
}

public static List<Result> analyzeDirectory(String directoryPath) {
List<Result> allResults = new ArrayList<>();
Path root = Paths.get(directoryPath);

try {
Files.walk(root)
.filter(Files::isRegularFile)
.filter(p -> p.toString().endsWith(".java"))
.forEach(filePath -> {
List<Vulnerability> results = analyzeFile(filePath.toString());
if (!results.isEmpty()) {
allResults.add(new Result(filePath.toString(), results));
}
});
} catch (IOException e) {
e.printStackTrace();
}

return allResults;
}

public static List<Vulnerability> analyzeFile(String filePath) {
List<Vulnerability> vulnerabilities = new ArrayList<>();

try {
CompilationUnit cu = JavaParser.parse(new File(filePath));

// Dependency-Check analysis
File pomFile = null;
if (SystemUtils.IS_OS_WINDOWS) {
pomFile = new File(PathUtil.getFilePath(filePath, "..\\pom.xml"));
} else {
pomFile = new File(PathUtil.getFilePath(filePath, "../pom.xml"));
}
DependencyCheck dependencyCheck = new DependencyCheck();
dependencyCheck.addAnalyzer(new Analyzer());
dependencyCheck.getAnalyzers().get(0).setFiles(FileUtils.listFiles(new File(filePath).getParentFile(), new String[]{"java"}, true));
dependencyCheck.scan();
dependencyCheck.getDependencies().forEach(dependency -> {
vulnerabilities.addAll(dependency.getVulnerabilities());
});

// Custom visitor to analyze method calls (example)
new MethodVisitor().visit(cu, vulnerabilities);
} catch (ParseException | IOException | AnalysisException e) {
e.printStackTrace();
}

return vulnerabilities;
}

// Custom visitor to analyze method calls (example)
private static class MethodVisitor extends VoidVisitorAdapter<List<Vulnerability>> {
@Override
public void visit(MethodCallExpr methodCall, List<Vulnerability> vulnerabilities) {
super.visit(methodCall, vulnerabilities);
// Example vulnerability detection
if (methodCall.getNameAsString().equals("exec")) {
int line = methodCall.getRange().map(r -> r.begin.line).orElse(-1);
vulnerabilities.add(new Vulnerability("Use of 'exec' method detected", "Rule123", "High", "Avoid using 'exec' method", line));
}
}
}

// Custom class to represent vulnerabilities found
private static class Vulnerability {
private String name;
private String id;
private String severity;
private String description;
private String recommendation;
private int line;

public Vulnerability(String name, String id, String severity, String description, String recommendation) {
this.name = name;
this.id = id;
this.severity = severity;
this.description = description;
this.recommendation = recommendation;
}

public Vulnerability(String name, String id, String severity, String description, String recommendation, int line) {
this.name = name;
this.id = id;
this.severity = severity;
this.description = description;
this.recommendation = recommendation;
this.line = line;
}

public String getName() {
return name;
}

public String getId() {
return id;
}

public String getSeverity() {
return severity;
}

public String getDescription() {
return description;
}

public String getRecommendation() {
return recommendation;
}

public int getLine() {
return line;
}
}

// Custom class to hold results for a file
private static class Result {
private String file;
private List<Vulnerability> vulnerabilities;

public Result(String file, List<Vulnerability> vulnerabilities) {
this.file = file;
this.vulnerabilities = vulnerabilities;
}

public String getFile() {
return file;
}

public List<Vulnerability> getVulnerabilities() {
return vulnerabilities;
}
}
}
